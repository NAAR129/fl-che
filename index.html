<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Garten-Puzzle: Wachstum & Raster</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700&display=swap" rel="stylesheet">
    <style>
        :root { --sky: #e3f2fd; --border: #0288d1; --water: #29b6f6; --grid-line: #cfd8dc; }
        body { font-family: 'Nunito', sans-serif; background: var(--sky); display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; overflow: hidden; }
        
        .game-container { background: white; border: 6px solid var(--border); border-radius: 40px; padding: 25px; display: flex; gap: 30px; box-shadow: 0 15px 0 #01579b; position: relative; width: 950px; }
        
        .garden-wrapper { text-align: center; flex: 1; }
        
        /* Das Gitter-Design */
        .grid { 
            display: grid; 
            grid-template-columns: repeat(10, 40px); 
            grid-template-rows: repeat(10, 40px); 
            gap: 2px; 
            background: var(--grid-line); 
            border: 4px solid #33691e; 
            position: relative; 
            width: 418px; 
            height: 418px; 
            margin: 0 auto;
        }
        .cell { 
            width: 40px; 
            height: 40px; 
            background: #f1f8e9; 
            box-sizing: border-box;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .sidebar { width: 320px; display: flex; flex-direction: column; gap: 10px; }
        
        .mega-water-btn {
            background: var(--water); color: white; border: none; padding: 15px; border-radius: 20px;
            font-family: 'Fredoka One'; cursor: pointer; transition: 0.3s; box-shadow: 0 5px 0 #0288d1;
        }

        .rotate-btn {
            background: #ffb300; color: white; border: none; padding: 10px; border-radius: 20px;
            font-family: 'Fredoka One'; cursor: pointer; transition: 0.3s; box-shadow: 0 4px 0 #fb8c00;
            font-size: 0.9em;
        }

        .cancel-btn {
            background: #e53935; color: white; border: none; padding: 10px; border-radius: 20px;
            font-family: 'Fredoka One'; cursor: pointer; transition: 0.3s; box-shadow: 0 4px 0 #b71c1c;
            font-size: 0.9em;
        }

        .plant-card { background: #fff; border: 3px solid #eee; border-radius: 15px; padding: 10px; cursor: grab; display: flex; align-items: center; gap: 12px; }

        .placed-plant { 
            position: absolute; border: 2px solid rgba(0,0,0,0.2); border-radius: 4px; 
            display: grid; cursor: move; box-sizing: border-box; z-index: 10;
            transition: transform 0.2s;
        }
        
        .stage-0 { filter: grayscale(1) brightness(1.2); }
        .stage-1 { filter: sepia(1) hue-rotate(90deg); }
        .stage-2 { filter: saturate(0.8); }
        .stage-3 { filter: saturate(1.5) drop-shadow(0 0 5px gold); border: 2px solid gold !important; }

        .thirsty { border: 3px solid var(--water) !important; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(41, 182, 246, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(41, 182, 246, 0); } 100% { box-shadow: 0 0 0 0 rgba(41, 182, 246, 0); } }
        .thirsty::after { content: 'üíß'; position: absolute; top: -12px; right: -12px; font-size: 22px; z-index: 20; }

        #overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(103, 58, 183, 0.95); border-radius: 35px; z-index: 100;
            flex-direction: column; justify-content: center; align-items: center; color: white;
        }
        #overlay input { font-size: 2.5em; width: 150px; text-align: center; border-radius: 15px; border: none; font-family: 'Fredoka One'; margin-top: 15px; }
        
        .stats { background: #0288d1; color: white; padding: 10px; border-radius: 50px; font-family: 'Fredoka One'; margin-top: 15px; }
    </style>
</head>
<body>

<div class="game-container">
    <div id="overlay">
        <h2 id="overlay-title" style="font-family:'Fredoka One'">Aufgabe</h2>
        <div style="font-size: 2.5em;"><span id="calc-text">?</span> = ?</div>
        <input type="number" id="math-answer">
    </div>

    <div class="garden-wrapper">
        <h1 style="font-family:'Fredoka One'; color:var(--border); margin:0;">üå± Wachstums-Garten</h1>
        <p style="font-size:0.8em; margin-bottom:3px;">
            <b>Klick üíß zum Gie√üen</b> | <b>M</b> zum Drehen (PC)
        </p>
        <p style="font-size:0.7em; margin-top:0; margin-bottom:8px; color:#555;">
            <b>Auf Tablets:</b> Ziehe mit dem Finger eine Pflanze in den Garten.
            F√§hrt die Figur √ºber ‚Üª, dreht sie sich. F√§hrst du mit der Figur √ºber den roten ‚ùå-Knopf, verschwindet sie wieder.
        </p>

        <div class="grid" id="garden-grid" 
             ondragover="handleDragOver(event)" 
             ondrop="handleDrop(event)"></div>
        <div class="stats">Belegte Fl√§che: <span id="area-val">0</span> / 100 m¬≤</div>
    </div>

    <div class="sidebar">
        <button class="mega-water-btn" onclick="startMegaWatering()">üöø ALLES GIE·∫ûEN (Profi-Multiplikation)</button>
        <button class="rotate-btn" onclick="rotateCurrentShapeBeforeDrop()">‚Üª Form drehen (vor dem Platzieren)</button>
        <h3 style="margin:5px 0;">Samen-Vorrat:</h3>

        <!-- Plant Cards -->
        <div class="plant-card" draggable="true"
             ondragstart="startDrag(event, 4, 4, 'üéÉ', '#fb8500')"
             ontouchstart="startTouchDragFromSeed(event, 4, 4, 'üéÉ', '#fb8500')">
            <span>üéÉ K√ºrbis (4x4)</span>
        </div>
        <div class="plant-card" draggable="true"
             ondragstart="startDrag(event, 3, 2, 'üåΩ', '#ffc107')"
             ontouchstart="startTouchDragFromSeed(event, 3, 2, 'üåΩ', '#ffc107')">
            <span>üåΩ Mais (3x2)</span>
        </div>
        <div class="plant-card" draggable="true"
             ondragstart="startDrag(event, 2, 2, 'üçì', '#e91e63')"
             ontouchstart="startTouchDragFromSeed(event, 2, 2, 'üçì', '#e91e63')">
            <span>üçì Erdbeere (2x2)</span>
        </div>
        <div class="plant-card" draggable="true"
             ondragstart="startDrag(event, 1, 1, 'ü•ï', '#ff9800')"
             ontouchstart="startTouchDragFromSeed(event, 1, 1, 'ü•ï', '#ff9800')">
            <span>ü•ï Karotte (1x1)</span>
        </div>
        <!-- NUEVA PLANTA 1x5 -->
        <div class="plant-card" draggable="true"
             ondragstart="startDrag(event, 1, 5, 'üåª', '#ffd54f')"
             ontouchstart="startTouchDragFromSeed(event, 1, 5, 'üåª', '#ffd54f')">
            <span>üåª Sonnenblume (1x5)</span>
        </div>

        <button class="cancel-btn" onclick="cancelCurrentShape()">‚ùå Pflanze verwerfen</button>
    </div>
</div>

<script>
    const grid = document.getElementById('garden-grid');
    const overlay = document.getElementById('overlay');
    const ansInput = document.getElementById('math-answer');
    const rotateBtn = document.querySelector('.rotate-btn');
    const cancelBtn = document.querySelector('.cancel-btn');

    let draggedInfo = null;
    let hoveredId = null;
    let pendingTask = null;
    let occupancy = Array(10).fill().map(() => Array(10).fill(null));

    const STAGE_ICONS = { 0: 'üå±', 1: 'üåø' };
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const CELL_SIZE = 42;

    const thirstTimers = {};

    let touchDrag = {
        active: false,
        w: 0,
        h: 0,
        icon: '',
        color: '',
        col: null,
        row: null,
        ghost: null,
        overRotateBtn: false,
        overCancelBtn: false
    };

    for (let i = 0; i < 100; i++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        grid.appendChild(cell);
    }

    document.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();
        if (key === 'm') {
            if (touchDrag.active || draggedInfo) {
                rotateCurrentShapeBeforeDrop();
            } else if (hoveredId) {
                rotatePlant(hoveredId);
            }
        }
        if (e.key === 'Enter' && overlay.style.display === 'flex') checkMath();
    });

    function handleDragOver(ev) { ev.preventDefault(); }

    function startDrag(ev, w, h, icon, color, isNew = true, existingId = null) {
        if (isTouchDevice) return;
        draggedInfo = { w, h, icon, color, isNew, existingId };
        if (existingId) document.getElementById(existingId).style.opacity = "0.4";
    }

    function isAreaFree(col, row, w, h, ignoreId = null) {
        if (col < 0 || row < 0 || col + w > 10 || row + h > 10) return false;
        for (let r = row; r < row + h; r++) {
            for (let c = col; c < col + w; c++) {
                if (occupancy[r][c] !== null && occupancy[r][c] !== ignoreId) return false;
            }
        }
        return true;
    }

    function handleDrop(ev) {
        if (isTouchDevice) return;
        ev.preventDefault();
        const rect = grid.getBoundingClientRect();
        let colRaw = Math.floor((ev.clientX - rect.left) / CELL_SIZE);
        let rowRaw = Math.floor((ev.clientY - rect.top) / CELL_SIZE);

        if (!draggedInfo) return;
        const { w, h, icon, color, isNew, existingId } = draggedInfo;

        const col = Math.max(0, Math.min(10 - w, colRaw));
        const row = Math.max(0, Math.min(10 - h, rowRaw));

        if (isAreaFree(col, row, w, h, existingId)) {
            if (isNew) {
                pendingTask = { type: 'place', col, row, w, h, icon, color, result: w * h };
                showOverlay("Neue Pflanze!", `${w} x ${h}`);
            } else {
                movePlant(existingId, col, row);
            }
        } else if (existingId) {
            document.getElementById(existingId).style.opacity = "1";
        }
        updateArea();
        draggedInfo = null;
    }

    function showOverlay(title, text) {
        document.getElementById('overlay-title').innerText = title;
        document.getElementById('calc-text').innerText = text;
        ansInput.value = '';
        overlay.style.display = 'flex';
        ansInput.focus();
    }

    function checkMath() {
        const val = parseInt(ansInput.value);
        if (val === pendingTask.result) {
            overlay.style.display = 'none';
            if (pendingTask.type === 'place') {
                placePlant(pendingTask.col, pendingTask.row, pendingTask.w, pendingTask.h, pendingTask.icon, pendingTask.color);
            } else if (pendingTask.type === 'water_single') {
                growPlant(pendingTask.id);
            } else if (pendingTask.type === 'water_mega') {
                document.querySelectorAll('.thirsty').forEach(p => growPlant(p.id));
            }
        } else {
            alert("Nicht ganz! Probier es noch einmal.");
        }
    }

    function placePlant(col, row, w, h, icon, color) {
        const id = 'p' + Date.now();
        const div = document.createElement('div');
        div.id = id; div.className = 'placed-plant stage-0';
        div.dataset.w = w; div.dataset.h = h; div.dataset.col = col; div.dataset.row = row;
        div.dataset.icon = icon; div.dataset.color = color; div.dataset.stage = "0";
        
        renderIcons(div, w, h, STAGE_ICONS[0]);
        div.style.left = (col * CELL_SIZE) + 'px'; 
        div.style.top = (row * CELL_SIZE) + 'px';
        div.style.backgroundColor = color;
        div.draggable = true;
        
        div.ondragstart = (e) => startDrag(e, parseInt(div.dataset.w), parseInt(div.dataset.h), icon, color, false, id);
        div.onmouseenter = () => hoveredId = id;
        div.onmouseleave = () => { if (hoveredId === id) hoveredId = null; };
        
        div.onclick = () => {
            const stage = parseInt(div.dataset.stage);
            if (stage >= 3) return;
            if (div.classList.contains('thirsty')) {
                const n1 = Math.floor(Math.random() * 20) + 10;
                const n2 = Math.floor(Math.random() * 20) + 10;
                pendingTask = { type: 'water_single', id: id, result: n1 + n2 };
                showOverlay("Gie√üen!", `${n1} + ${n2}`);
            }
        };

        grid.appendChild(div);
        updateOccupancy(id, col, row, w, h);
        startThirstTimer(id);
        updateArea();
    }

    function growPlant(id) {
        const el = document.getElementById(id);
        if (!el) return;
        let stage = parseInt(el.dataset.stage);
        if (stage < 3) stage++;
        if (stage > 3) stage = 3;
        el.dataset.stage = stage;
        el.className = `placed-plant stage-${stage}`;
        
        let currentIcon = el.dataset.icon;
        if (stage === 0) currentIcon = STAGE_ICONS[0];
        else if (stage === 1) currentIcon = STAGE_ICONS[1];
        
        renderIcons(el, parseInt(el.dataset.w), parseInt(el.dataset.h), currentIcon);
        el.classList.remove('thirsty');

        if (thirstTimers[id]) {
            clearTimeout(thirstTimers[id]);
            delete thirstTimers[id];
        }
        if (stage < 3) startThirstTimer(id);
    }

    function startThirstTimer(id) {
        const el = document.getElementById(id);
        if (!el) return;
        const stage = parseInt(el.dataset.stage);
        if (stage >= 3) return;

        if (thirstTimers[id]) {
            clearTimeout(thirstTimers[id]);
            delete thirstTimers[id];
        }

        const time = 20000 + Math.random() * 10000; 
        thirstTimers[id] = setTimeout(() => {
            const el2 = document.getElementById(id);
            if (!el2) return;
            const st = parseInt(el2.dataset.stage);
            if (st < 3) el2.classList.add('thirsty');
        }, time);
    }

    function startMegaWatering() {
        if (document.querySelectorAll('.thirsty').length === 0) return alert("Alles nass!");
        const n1 = Math.floor(Math.random() * 5) + 11;
        const n2 = Math.floor(Math.random() * 6) + 4;
        pendingTask = { type: 'water_mega', result: n1 * n2 };
        showOverlay("Mega-Gie√üen!", `${n1} x ${n2}`);
    }

    function updateOccupancy(id, col, row, w, h, remove = false) {
        for (let r = row; r < row + h; r++) {
            for (let c = col; c < col + w; c++) occupancy[r][c] = remove ? null : id;
        }
    }

    function movePlant(id, newCol, newRow) {
        const el = document.getElementById(id);
        updateOccupancy(id, parseInt(el.dataset.col), parseInt(el.dataset.row), parseInt(el.dataset.w), parseInt(el.dataset.h), true);
        el.dataset.col = newCol; el.dataset.row = newRow;
        el.style.left = (newCol * CELL_SIZE) + 'px'; 
        el.style.top = (newRow * CELL_SIZE) + 'px';
        el.style.opacity = "1";
        updateOccupancy(id, newCol, newRow, parseInt(el.dataset.w), parseInt(el.dataset.h));
        updateArea();
    }

    function renderIcons(el, w, h, icon) {
        el.innerHTML = '';
        el.style.gridTemplateColumns = `repeat(${w}, 40px)`;
        el.style.gridTemplateRows = `repeat(${h}, 40px)`;
        el.style.gap = '2px';
        for (let i = 0; i < (w * h); i++) {
            const b = document.createElement('div');
            b.style.display = 'flex'; b.style.alignItems = 'center'; b.style.justifyContent = 'center';
            b.style.fontSize = '22px'; b.style.width = '40px'; b.style.height = '40px';
            b.innerText = icon; el.appendChild(b);
        }
    }

    function rotatePlant(id) {
        const el = document.getElementById(id);
        if (!el || el.classList.contains('thirsty')) return;
        const oldW = parseInt(el.dataset.w), oldH = parseInt(el.dataset.h);
        const col = parseInt(el.dataset.col), row = parseInt(el.dataset.row);
        if (isAreaFree(col, row, oldH, oldW, id)) {
            updateOccupancy(id, col, row, oldW, oldH, true);
            el.dataset.w = oldH; el.dataset.h = oldW;
            const stage = parseInt(el.dataset.stage);
            let icon = el.dataset.icon;
            if (stage === 0) icon = STAGE_ICONS[0];
            else if (stage === 1) icon = STAGE_ICONS[1];
            renderIcons(el, oldH, oldW, icon);
            updateOccupancy(id, col, row, oldH, oldW);
            updateArea();
        }
    }

    function updateArea() {
        let total = 0;
        document.querySelectorAll('.placed-plant').forEach(p => total += parseInt(p.dataset.w) * parseInt(p.dataset.h));
        document.getElementById('area-val').innerText = total;
    }

    function createGhost(w, h, icon, color) {
        const ghost = document.createElement('div');
        ghost.className = 'placed-plant';
        ghost.style.position = 'fixed';
        ghost.style.pointerEvents = 'none';
        ghost.style.opacity = '0.7';
        ghost.style.backgroundColor = color;
        ghost.style.zIndex = '999';
        renderIcons(ghost, w, h, icon);
        document.body.appendChild(ghost);
        return ghost;
    }

    function updateGhostAndCellFromTouch(touch) {
        const rect = grid.getBoundingClientRect();
        let col = Math.floor((touch.clientX - rect.left) / CELL_SIZE);
        let row = Math.floor((touch.clientY - rect.top) / CELL_SIZE);

        col = Math.max(0, Math.min(10 - touchDrag.w, col));
        row = Math.max(0, Math.min(10 - touchDrag.h, row));

        touchDrag.col = col;
        touchDrag.row = row;

        if (touchDrag.ghost) {
            const screenLeft = rect.left + col * CELL_SIZE;
            const screenTop  = rect.top  + row * CELL_SIZE;
            touchDrag.ghost.style.left = screenLeft + 'px';
            touchDrag.ghost.style.top  = screenTop  + 'px';
        }
    }

    function isTouchOverRotateBtn(touch) {
        if (!rotateBtn) return false;
        const rect = rotateBtn.getBoundingClientRect();
        return (
            touch.clientX >= rect.left &&
            touch.clientX <= rect.right &&
            touch.clientY >= rect.top &&
            touch.clientY <= rect.bottom
        );
    }

    function isTouchOverCancelBtn(touch) {
        if (!cancelBtn) return false;
        const rect = cancelBtn.getBoundingClientRect();
        return (
            touch.clientX >= rect.left &&
            touch.clientX <= rect.right &&
            touch.clientY >= rect.top &&
            touch.clientY <= rect.bottom
        );
    }

    function startTouchDragFromSeed(ev, w, h, icon, color) {
        if (!isTouchDevice) return;
        const touch = ev.touches && ev.touches[0];
        if (!touch) return;
        ev.preventDefault();

        touchDrag.active = true;
        touchDrag.w = w;
        touchDrag.h = h;
        touchDrag.icon = icon;
        touchDrag.color = color;
        touchDrag.col = null;
        touchDrag.row = null;
        touchDrag.overRotateBtn = false;
        touchDrag.overCancelBtn = false;
        touchDrag.ghost = createGhost(w, h, icon, color);

        updateGhostAndCellFromTouch(touch);
    }

    function handleTouchMove(ev) {
        if (!touchDrag.active) return;
        const touch = ev.touches && ev.touches[0];
        if (!touch) return;
        ev.preventDefault();

        updateGhostAndCellFromTouch(touch);

        const overBtn = isTouchOverRotateBtn(touch);
        if (overBtn && !touchDrag.overRotateBtn) {
            rotateCurrentShapeBeforeDrop();
        }
        touchDrag.overRotateBtn = overBtn;

        const overCancel = isTouchOverCancelBtn(touch);
        if (overCancel && !touchDrag.overCancelBtn) {
            cancelCurrentShape();
            touchDrag.overCancelBtn = overCancel;
            return;
        }
        touchDrag.overCancelBtn = overCancel;
    }

    function handleTouchEnd(ev) {
        if (!touchDrag.active) return;

        if (touchDrag.ghost) {
            document.body.removeChild(touchDrag.ghost);
        }

        const col = touchDrag.col;
        const row = touchDrag.row;
        const w = touchDrag.w;
        const h = touchDrag.h;
        const icon = touchDrag.icon;
        const color = touchDrag.color;

        touchDrag.active = false;
        touchDrag.ghost = null;
        touchDrag.overRotateBtn = false;
        touchDrag.overCancelBtn = false;

        if (col == null || row == null) return;
        if (!isAreaFree(col, row, w, h, null)) return;

        pendingTask = { type: 'place', col, row, w, h, icon, color, result: w * h };
        showOverlay("Neue Pflanze!", `${w} x ${h}`);
    }

    function rotateCurrentShapeBeforeDrop() {
        if (touchDrag.active) {
            const oldW = touchDrag.w;
            const oldH = touchDrag.h;
            touchDrag.w = oldH;
            touchDrag.h = oldW;

            if (touchDrag.ghost) {
                renderIcons(touchDrag.ghost, touchDrag.w, touchDrag.h, touchDrag.icon);
            }

            if (touchDrag.col !== null && touchDrag.row !== null) {
                const rect = grid.getBoundingClientRect();
                let col = Math.max(0, Math.min(10 - touchDrag.w, touchDrag.col));
                let row = Math.max(0, Math.min(10 - touchDrag.h, touchDrag.row));
                touchDrag.col = col;
                touchDrag.row = row;

                const screenLeft = rect.left + col * CELL_SIZE;
                const screenTop  = rect.top  + row * CELL_SIZE;
                touchDrag.ghost.style.left = screenLeft + 'px';
                touchDrag.ghost.style.top  = screenTop  + 'px';
            }
        } 
        else if (draggedInfo) {
            const oldW = draggedInfo.w;
            draggedInfo.w = draggedInfo.h;
            draggedInfo.h = oldW;
        }
    }

    function cancelCurrentShape() {
        if (touchDrag.active) {
            if (touchDrag.ghost) {
                document.body.removeChild(touchDrag.ghost);
            }
            touchDrag.active = false;
            touchDrag.ghost = null;
            touchDrag.col = null;
            touchDrag.row = null;
            touchDrag.overRotateBtn = false;
            touchDrag.overCancelBtn = false;
        }
        draggedInfo = null;
        pendingTask = null;
    }

    if (isTouchDevice) {
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
    }
</script>
</body>
</html>
